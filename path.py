"""Methods to provide absolute paths to host and Cell file systems and to perform interaction
with the host file system.

.. note::
    Throughout this HTML document, a forward slash ("/") for path strings is used instead of a
    backslash, even in Windows-specific paths, because the backslash is used as escape in both
    Python docstring as well as the ReStructuredText. One backslash must be expressed as four
    backslashes; "/" avoids that.

Summary
=======

This module specifies the directory and file paths as used in the Serpente source code as well as
methods to access these paths. The locations of folders on the Host and the Cell are identified,
common system-agnostic functions are presented so that Serpente modules may select directory paths
specific to intended purpose, and efficient host path handling functions are specified to allow the
Serpente modules to download host files to the cell and upload cell files to the host. Because the
Serpente code is developed in a Windows-based PyCharm IDE, and tested in MDW local mode as well as
MDW real mode, where MDW may run with the Windows-like Pharlap OS or the Linux OS, the Serpente code
must be able to accommodate file paths of different formats and locations.

The path management methods will select the locations and formats appropriate for the operating
environment, allowing the Serpente process and test code to avoid conditionally selecting those
characteristics.

For the foreseeable future, the host is a Windows PC (Release 10+), and the primary directory path
on the PC is C:/Xyratex/Stw, also call the "MDW Root Path". Most folders of interest to the Serpente
process code are found under this root path, although some legacy process code accesses other paths
elsewhere under C:/.

Operating Environment Distinctions
==================================
To illustrate the differences in file paths in the various environments, ignoring the Windows-based
PyCharm development for now, consider a file named "sample.json" is to be located on the host
(which will always be Windows 10 or higher) in the directory of "C:/Xyratex/Stw/config", and
consider downloading that file into temporary "config" folder on the Cell.

.. list-table::
   :header-rows: 1

   * - Environment
     - File Path Format
   * - On host (Windows)
     - C:/Xyratex/Stw/config/sample.json
   * - On Cell (MDW Local Mode)
     - C:/RAMDISK/config/sample.json (on Windows dev system)
   * - On Cell (MDW Pharlap)
     - D:/config/sample.json (On MDW HW)
   * - On Cell (MDW Linux)
     - /usr/mdw/temporary/config/sample.json (On MDW HW)

Declaration of Folders
======================
A set of folders on the host are defined here which will be used to hold all program files, all
configuration files, all data files, all temporary files, all log files as required for the ESF
software and the Serpente software. Many of those folders are defined for ESF and created by the
ESF MDW Installer. The remaining should be created by the Serpente Installer.

Serpente process modules require various configuration (JSON) and read-only data files. Many of
these are contained in folders in the serpente-source repository; repository files will be copied
to the MDW Root Path by the Test Runner. Still other configuration files are maintained externally
to the serpente repository in other git repositories; the Serpente Installer is responsible for
their deployment to the MDW Root Path.

Host Folder Paths
-----------------
The host folders are found under the "MDW Root Path" of C:/Xyratex/Stw. Many legacy folders are
rooted at C:/; however, Serpente architecture is such that all files are to be located under the
MDW root path. The DataCollection folder is used to hold all persistent data files and log files
from the ESF SW as well as Serpente process code; these remain in place unless manually deleted.
The Temp folder holds temporary files generated by ESF and Serpente that may be removed or
altered upon Cell reboot or start of the Cell Monitor utility (STWCCC) on the host.

.. list-table::
   :header-rows: 1

   * - Folder
     - Path
     - Created By
   * - Assembler
     - C:/Xyratex/Stw/Assembler
     - ESF MDW Installer
   * - DataCollection
     - C:/Xyratex/Stw/DataCollection
     - ESF MDW Installer
   * - Emergencylogs
     - C:/Xyratex/Stw/emergencylogs
     - ESF MDW Installer
   * - Firmware
     - C:/Xyratex/Stw/Firmware
     - ESF MDW Installer
   * - Python
     - C:/Xyratex/Stw/python
     - ESF MDW Installer
   * - Tables
     - C:/Xyratex/Stw/Tables
     - ESF MDW Installer
   * - Temp
     - C:/Xyratex/Stw/Temp
     - ESF MDW Installer
   * - Test
     - C:/Xyratex/Stw/Test
     - MDW Unit Test Installer
   * - TestFiles (ESF)
     - C:/Xyratex/Stw/TestFiles
     - MDW Unit Test Installer
   * - testfiles (Serpente)
     - C:/Xyratex/Stw/python/eng/unittests/testfiles
     - Serpente Installer
   * - XyIni
     - C:/Xyratex/Stw/xyIni
     - ESF MDW Installer
   * - Config (JSON)
     - C:/Xyratex/Stw/config
     - Serpente Installer
   * - Store
     - C:/Xyratex/Stw/Store
     - Serpente Installer

Cell Folder Paths
-----------------
The cell has two volumes in its file system ("FS"): a persistent volume preserved across reboots,
and a temporary volume which is totally cleared of all files and folders after a reboot.

In the MDW hardware system with the Pharlap OS, the persistent volume is in flash memory with the
FS system root of "C:/", and the temporary volume is in SDRAM with the FS root of "D:/"

In the MDW local mode system with an emulation running on Windows 10 (and using Windows file
system), the persistent volume is provided by "C:/FLASHDISK", and "C:/RAMDISK" is used for the
temporary volume.

In MDW Linux, the volumes are yet to be determined, but a persistent and temporary volume are
expected.

One folder in the persistent volume is planned (Store), however, there are several folders planned
for the temporary volume:

.. list-table::
   :header-rows: 1
   :widths: 25 75

   * - Cell Temp Folder
     - Purpose
   * - Bypass38
     - All Python modules downloaded from the host through a "bypass" mechanism is placed in
       Bypass38 or in a subpath under Bypass38
   * - Temp
     - Temporary files (created and deleted during one cell session) are placed in the Temp folder.
       They can be placed at the root of the temporary volume, but having a Temp folder makes the
       distinction more obvious.
   * - Config
     - Temporary configuration files (JSON) downloaded from the host may be placed in the Config
       folder. They can be placed at the root of the temporary volume, but having a Config folder
       makes the distinction more obvious.
   * - Data
     - Temporary data files generated by Serpente may be placed in the Data folder. They can be
       placed at the root of the temporary volume, but having a Data folder makes the distinction
       more obvious.

Data Folders
------------
Development of process code and test modules necessarily requires default configuration and data
files which are maintained in the serpente repository. However, when any process code or test module
is run, all configuration and data files must be located under the MDW root path. The developer can
"manually" copy the files of interest from repository to MDW root path; a unit test deployment
utility is also available to assist the developer in the repository-to-MDW copy.

.. list-table:: Default Process Configuration Files
   :header-rows: 1
   :widths: 30 50

   * - Repository Folder
     - Destination Path
   * - <repo>/assembler
     - C:/Xyratex/Stw/assembler
   * - <repo>/config
     - C:/Xyratex/Stw/config
   * - <repo>/xyini
     - C:/Xyratex/Stw/xyIni

.. list-table:: Test Data Files
   :header-rows: 1
   :widths: 30 50

   * - Repository Folder
     - Destination Path
   * - <repo>/python/eng/unittests/testfiles
     - C:/Xyratex/Stw/TestFiles

Ordinarily, the default process configuration files are installed into the MDW root path by the
Serpente Installer. However, a developer may wish to copy modified "default" process data files or
test data files from repository to the MDW root path; the "path.host.installTestFiles" method may be
explicitly called in a test module setup to copy specific files to the MDW root path. In the Windows
operating mode, the TestRunner will automatically copy all files to the
"eng/unittests/testfiles" folder in the MDW root path, retaining their subpaths within
subdirectories.

"path.py" Module
================
The system/path.py module provides public methods which provide the following:

.. list-table::
    :widths: 25 75

    * - **Path Getter Methods**
      - Return absolute paths to host and Cell file systems. The module manages all distinctions
        of OS and operating environment for both systems such that the calling module does not
        need to be aware of the OS characteristics; instead, only the purpose of folder.
    * - **Cell Access Methods**
      - Perform cell folder creation and deletion, check cell file existence.
    * - **Host Access Methods**
      - Perform host folder creation and deletion, host file download to cell, upload cell file to
        host, check host file existence.

The "path.py" module provides two classes, "cell" and "host," which qualify the getter function and
access function. For example, both cell and host have a Temp folder. The appropriate references
would be **path.cell.tempPath()** and **path.host.tempPath()**.

The "getter" methods (those with names ending in "Path") allows the total elimination of
references to "os.path.join" (although "os.path.join" is always permitted for cell paths).

Each of the following "..Path" methods returns the absolute path for the targeted file system,
given any of these input parameters.


Path Getter Methods
-------------------
.. list-table::
   :header-rows: 1
   :widths: 40 60

   * - Signature
     - Action
   * - ...Path()
     - Return base path for the named function
   * - ...Path(name)
     - Return path to 'name' (file or folder) under the base path
   * - ...Path(f1, f2, ..., name)
     - Return path to f1/f2/.../name under base path
   * - ...Path([f1,f2,...,name])
     - Return path to f1/f2/.../name under base path
   * - ...Path('f1/f2/name')
     - Return path to f1/f2/.../name under base path

In each signature, the resulting returned path will use the path separator appropriate to the target
file system. Any of the inputs may specify either path separator of slash or backslash; the ...Path
function will convert as needed.

To import the path.py module and get access to its public methods, the preferred statement is
**import system.path as path** and all references to methods are based on **path.cell** or
**path.host**.

Host And Cell Access Methods
----------------------------
While the Path getter methods are useful to get target-specific paths, there is a need to provide
consistent, simple, and convenient methods to download file from host to cell and from cell to host,
create folders, remove files, etc. The host access methods (in the "path.Host" class) provides those
and more for handling host path operations. The cell access methods (in the
"path.Cell" class) provides those and more for handling cell path operations.

Many of the host and cell access methods have the same name and similar functionality as in the
"os" and "os.path" Python libraries of which the developer is already familiar. Two distinctions
from the standard os and os.path methods, however, are that for many functions their returned path
strings will be converted to have the path separator of the target system, and that exceptions in
all access methods raise "PathError" rather than one of several OS exceptions.

Some of the access methods are defined as context managers, permitting cleanup of interim cell files
after the operations.

"path.host" and "path.cell" Getter Methods
==========================================

.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - Function
     - Action
   * - path.host.aperioIniPath
     - Location of Aperio INI files (in legacy, located in the MDW root path)
   * - path.host.asmPath
     - Assember folder in MDW root path
   * - path.host.configPath
     - Config folder in MDW root path
   * - path.host.dataPath
     - Data folder in MDW root path
   * - path.host.iniPath
     - xyIni folder in MDW root path
   * - path.host.logPath
     - DataCollection folder in MDW root path
   * - path.host.rootPath
     - Primary "MDW root path" on Windows host
   * - path.host.join
     - Extend a full path with a subpath
   * - path.host.pythonPath
     - Python folder in MDW root path
   * - path.host.storePath
     - Data Store folder in MDW root path
   * - path.host.tempPath
     - Temp folder in MDW root path
   * - path.host.testfilesPath
     - testfiles folder in MDW root path
   * - path.host.unittestsPath
     - python/eng/unittests folder in MDW root path
   * - path.cell.configPath
     - Config folder in Cell RamDisk volume
   * - path.cell.dataPath
     - Data folder in Cell RamDisk volume
   * - path.cell.join
     - Extend a full path with a subpath
   * - path.cell.persistPath
     - Root path of Cell Flashdisk volume
   * - path.cell.storePath
     - Root path of persistent Data Store in Cell Flashdisk volume
   * - path.cell.subpathPath
     - Return a path subpath combining components of a branch
   * - path.cell.tempPath
     - Temp folder in Cell RamDisk volume

...Path Getter Examples
-----------------------
The "mep232211.ini" is found in the xyIni folder on the host. Assume it has also been downloaded
to "mep.ini' in the Cell temp folder (running on MDW Local Mode or Windows development)::

   >>> import system.path as path
   >>> host_file = path.host.iniPath('mep232211.ini')
   >>> print(host_file)
       C:/Xyratex/Stw/xyIni/mep232211.ini
   >>> cell_file = path.cell.tempPath('mep.ini')
   >>> print(cell_file)
       C:/RAMDISK/Temp/mep.ini

Cell Access Methods
===================
.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - Function
     - Action
   * - path.cell.createFolder
     - Create a directory path on the cell adding missing folders
   * - path.cell.removeFile
     - Remove a file from cell file system (flash or ram)
   * - path.cell.removeFolder
     - Remove a folder at the end of a cell path
   * - path.cell.sep
     - Variable that specifies the path separator character appropriate for the cell file system
   * - path.cell.abspath
     -
   * - path.cell.basename
     -
   * - path.cell.chdir
     -
   * - path.cell.dirname
     -
   * - path.cell.exists
     -
   * - path.cell.getcwd
     -
   * - path.cell.getmtime
     -
   * - path.cell.getsize
     -
   * - path.cell.isfile
     -
   * - path.cell.isdir
     -
   * - path.cell.join
     -
   * - path.cell.normpath
     -
   * - path.cell.relpath
     -
   * - path.cell.rmtree
     -
   * - path.cell.split
     -
   * - path.cell.splitdrive
     -
   * - path.cell.splitext
     -
   * - path.cell.makedirs
     -
   * - path.cell.remove
     -
   * - path.cell.removedirs
     -
   * - path.cell.rmdir
     -
   * - path.cell.stat
     -
   * - path.cell.unlink
     -
   * - path.cell.walk
     -

Host Access Methods
===================
.. list-table::
   :header-rows: 1
   :widths: 30 70

   * - Function
     - Action
   * - path.host.copyFile
     - Copy a file from one host folder to another
   * - path.host.createFolder
     - Create a directory path on the host adding missing folders
   * - path.host.downloadFile
     - Context manager to download a file on host and yield cell file name
   * - path.host.getFile
     - Download a file on host and return local file name
   * - path.host.installTestFiles
     - Install repository test files into the MDW Root Path
   * - path.host.loadFile
     - Download host file and return its contents as a string
   * - path.host.loadFileList
     - Download file and return its contents as list of lines
   * - path.host.loadFileObject
     - Download file and return its contents as a Python object
   * - path.host.removeFile
     - Remove file in host path
   * - path.host.removeFolder
     - Remove a folder at the end of a host path
   * - path.host.split
     - Split a host path string into base name and directory parts
   * - path.host.uploadFile
     - Copy file on Cell to host path
   * - path.host.abspath
     -
   * - path.host.basename
     -
   * - path.host.chdir
     -
   * - path.host.dirname
     -
   * - path.host.exists
     -
   * - path.host.getcwd
     -
   * - path.host.getmtime
     -
   * - path.host.getsize
     -
   * - path.host.isfile
     -
   * - path.host.isdir
     -
   * - path.host.join
     -
   * - path.host.normpath
     -
   * - path.host.relpath
     -
   * - path.host.rmtree
     -
   * - path.host.split
     -
   * - path.host.splitdrive
     -
   * - path.host.splitext
     -
   * - path.host.makedirs
     -
   * - path.host.remove
     -
   * - path.host.removedirs
     -
   * - path.host.rmdir
     -
   * - path.host.stat
     -
   * - path.host.unlink
     -

If an exception occurs during a path function, a "path.PathError" or "path.PathNotFoundError"
exception is raised, where the exception message explains its reason.

The host-to-Cell file transfer methods (download... and load... methods) download a host file, whose
path is obtained with a ...Path function, to a cell file. The load... methods read the cell file
into a string, list of strings, or a Python object. Then the cell file is deleted, unless the caller
wants to keep the cell file.

In many cases, use of these methods eliminate the need to import pynative for host functions.

path.host Examples
------------------
Example 1: Download config file "happy_heads.json" and compile. This downloads to a local file,
loads the json file, and deletes the local file::

    import system.path as path
    with path.host.downloadFile(path.host.configPath('happy_heads.json')) as jfile:
        json.load(jfile)

Example 2: Upload pattern file "EZ0.asm" generated on Cell to Host assembler folder::

    import system.path as path
    host_file = path.host.asmPath('EZ0.asm')
    asm_lines = generateAsmText()
    path.host.uploadFile(host_file, asm_file, contents=asm_lines)

Copyright (C) Seagate Technology LLC, 2021. All rights reserved.
"""
#pylint:disable=missing-return-type-doc,missing-return-doc
#pylint:disable=missing-yield-doc,missing-yield-type-doc
#pylint:disable=invalid-name
#pylint:disable=no-value-for-parameter
#pylint:disable=eval-used

from contextlib import contextmanager
import mdwec
import os
import pynative
import shutil
import sys
import time

__ALL__ = ['cell', 'host', 'PathError']

verbosity = getattr(sys, 'verbosity', 0)
on_windows = (sys.platform == 'win32')


def joiner(str1, str2, sep):
    """Helper function to join two strings with a separator

    If string 1 already ends in the separator, the return value is the concatenation of str1 and
    str2. Otherwise, the result is str1 + sep + str2. This function is necessary to define class
    variables which join root paths to folder names.
    """
    if str1.endswith(sep):
        return str1 + str2
    return str1 + sep + str2


class PathError(Exception):
    """Exception class for path.py errors

    This exception is returned for recognized ESF and OS exceptions, such that the path method
    caller need only be concerned with PathError exceptions. If the ESF "RcError" is encountered by
    a path method, its "rc" return code and "method" values are copied into the PathError instance.
    An explicit "rc" value can also be passed as the "rc" keyword.

    When PathError is raised within an exception, it should be raised from None (see example).
    However, if within the scope of a contextmanager, the PathError must not be raised from within
    an exception or it interfers with the contextmanager yield; rather, it is raised after leaving
    the scope.

    Parameters
    ----------
    args : Exception
        If the parameter is an RcError exception object, its rc value is used in the
        raised PathError instance. If an Exception object, its representation is used as the
        PathError message. Optional
    rc : str
        Provide a specific mdwec return code value. If a return code value is not provided,
        the generic XYB_RC_FAIL value is used. Optional.

    Raises
    ------
    PathError:
        An instance of PathError is raised, with "rc" attribute.

    Examples
    --------
    Example of raising PathError within an except block and of passing the ``RcError`` object::

        try:
            pynative.getfile('xxx', 'yyy')
        except RcError as exc:
            raise PathError(exc, "The getfile failed to get 'xxx'") from None
    """
    def __init__(self, *args, **kwargs):
        self.rc = 0
        self.message = None
        self.method = None

        for arg in args:
            if isinstance(arg, RcError):
                self.rc = arg.rc
                self.method = arg.method
            elif isinstance(arg, Exception) and self.message is None:
                if arg is FileNotFoundError:
                    self.rc = mdwec.XYB_RC_FILE_NOT_FOUND
                self.message = f"{arg}"
            elif isinstance(arg, str):
                self.message = arg
        if self.message is None:
            self.message = 'Error in path method'
        self.message = self.message.replace('\\\\', '\\')

    def __repr__(self):
        text = self.message if self.message else ''
        if self.rc: text += f"--ESF error rc={self.rc}, method={self.method}"
        return text
    def __str__(self):
        return self.__repr__()


class PathNotFoundError(PathError):
    """PathError for file or directory path not found, returning RcError value"""
    def __init__(self, fs_path):
        super(PathNotFoundError, self).__init__(rc=mdwec.XYB_RC_FILE_NOT_FOUND,
                                                message=f"{fs_path} not found")


class BasePath:
    """Base class for cell and host classes"""

    # Derived classes must declare their respective os path separator (sep) and the alternate
    # separator (_alt_sep) which if specified in a path is replaced with sep.
    sep = None
    _alt_sep = None

    @classmethod
    def abspath(cls, path):
        """Get absolute path--must be overloaded by derived class

        If the path is not started with a separator character, the current working directory is
        prefixed to the input string for the returned absolute path. For the host, the CWD is always
        the MDW root path.

        Parameters
        ----------
        path : str
            A full or partial path string

        Returns
        -------
        abspath : str
            The a fully qualified path

        """
        raise NotImplementedError    # Must be overloaded in derived class

    @classmethod
    def basename(cls, path):
        """Find filename part of a cell or host path.

        Extract the filename portion ("basename") of a path string. Note that if the input string
        ends with the path separator, the file name portion is consider omitted, returning an empty
        string for the basename.

        Parameters
        ----------
        path : str
            A full or partial path string

        Returns
        -------
        str:
            The file name part of the path string, delimited by path separator of any system.
        """
        return cls.split(path)[1]

    @classmethod
    def dirname(cls, path):
        """Find directory part of a cell or host path

        Extract the directory portion ("dirname") of a path string. Note that if the input string
        ends with the path separator, the file name portion is consider omitted, returning the
        entire input path string for the basename, without that ending separator. If there is no
        path separator anywhere in the input string, the directory portion is considered omitted,
        returning an empty string for the basename.

        Parameters
        ----------
        path : str
            A full or partial path string

        Returns
        -------
        str:
            The directory part of the path string, delimited by path separator of any system,
            or empty string if no directory portion is found.

        """
        return cls.split(path)[0]

    @classmethod
    def getcwd(cls):
        """Get current working directory"""
        raise NotImplementedError    # Must be overloaded in derived class

    @classmethod
    def isabs(cls, path):
        """Determine if a path is absolute

        Parameters
        ----------
        path : str
            A full or partial path string

        Returns
        -------
        is_abs : bool
            True if the input path appears to be an absolute directory or file path, on either
            cell or host.
        """
        path = cls.splitdrive(path)[1]
        return path and path[0] in '/\\'

    @classmethod
    def join(cls, root, *subpath):
        """Extend the path with the composed subpath

        This function is similar to os.path.join except that the subpath arguments may consist of
        lists or tuples as well as strings. Otherwise, the behavior is the same as os.path.join:

            Join one or more path components intelligently. The return value is the concatenation of
            path and any members of ``subpath`` with exactly one directory separator (os.sep)
            following each non-empty part except the last, meaning that the result will only end in
            a separator if the last part is empty. If a component is an absolute path, all previous
            components are thrown away and joining continues from the absolute path component.

            On Windows, the drive letter is not reset when an absolute path component (e.g.,
            '/foo') is encountered. If a component contains a drive letter, all previous components
            are thrown away and the drive letter is reset.

        Parameters
        ----------
        root : str
            Base path in cell or host to which subpath (if any) is appended.
        subpath : tuple or list
            The folders in a subpath, as a tuple or list, as separate parameters, or subpath string.

        Returns
        -------
        path : str
            Full path, with conversion of separator characters to that of the target system.
        """
        # Flatten list elements in subpath arguments
        full_subpath = []
        for sp in subpath:
            if sp is None: continue
            if isinstance(sp, str):
                full_subpath.append(sp)
            else:
                full_subpath += list(sp)
        subpath = full_subpath

        result_drive, result_path = cls.splitdrive(root.replace(cls._alt_sep, cls.sep))
        for p in subpath:
            p_drive, p_path = cls.splitdrive(p.replace(cls._alt_sep, cls.sep))
            if p_path and p_path[0] == cls.sep:
                # Second path is absolute
                if p_drive or not result_drive:
                    result_drive = p_drive
                result_path = p_path
                continue
            elif p_drive and p_drive != result_drive:
                if p_drive.lower() != result_drive.lower():
                    # Different drives => ignore the first path entirely
                    result_drive = p_drive
                    result_path = p_path
                    continue
                # Same drive in different case
                result_drive = p_drive
            # Second path is relative to the first
            if result_path and result_path[-1] != cls.sep:
                result_path = result_path + cls.sep
            result_path = result_path + p_path
        return result_drive + result_path

    @classmethod
    def normpath(cls, path):
        """Normalize path, eliminating double slashes, etc.

        Parameters
        ----------
        path : str
            A cell or host path string

        Returns
        -------
        str:
            A normalized path string with target-specific separators.
        """
        path = path.replace(cls._alt_sep, cls.sep)
        prefix, path = cls.splitdrive(path)

        # collapse initial backslashes
        if path.startswith(cls.sep):
            prefix += cls.sep
            path = path.lstrip(cls.sep)

        comps = path.split(cls.sep)
        i = 0
        while i < len(comps):
            if not comps[i] or comps[i] == '.':
                del comps[i]
            elif comps[i] == '..':
                if i > 0 and comps[i - 1] != '..':
                    del comps[i - 1:i + 1]
                    i -= 1
                elif i == 0 and prefix.endswith(cls.sep):
                    del comps[i]
                else:
                    i += 1
            else:
                i += 1
        # If the path is now empty, substitute '.'
        if not prefix and not comps:
            comps.append('.')
        return prefix + cls.sep.join(comps)

    @classmethod
    def relpath(cls, path, start=None):
        """Return a relative version of a path

        Parameters
        ----------
        path : str
            A cell or host path string; must be absolute path
        start : str, optional
            A cell or host path string;if not specified, the CWD is used

        Returns
        -------
        str:
            A normalized path string that is relative to the start path.
        """
        if start is None:
            start = cls.getcwd()
        if not path:
            raise PathError("The path parameter of relpath must be specified")
        start_abs = cls.normpath(cls.abspath(start))
        path_abs = cls.normpath(cls.abspath(path))
        start_drive, start_rest = cls.splitdrive(start_abs)
        path_drive, path_rest = cls.splitdrive(path_abs)
        if start_drive.lower() != path_drive.lower():
            raise PathError("Different mounts used in relpath paths")

        start_list = [x for x in start_rest.split(cls.sep) if x]
        path_list = [x for x in path_rest.split(cls.sep) if x]
        # Work out how much of the filepath is shared by start and path.
        i = 0
        for e1, e2 in zip(start_list, path_list):
            if e1.lower() != e2.lower():
                break
            i += 1
        rel_list = ['..'] * (len(start_list) - i) + path_list[i:]
        if not rel_list:
            return '.'
        return cls.join(*rel_list)

    @classmethod
    def split(cls, path):
        """ Split a file path into a base name and a directory part, for either cell or host.

        Parameters
        ----------
        path : str
            A path string as formatted for the host or for the cell.

        Returns
        -------
        tuple:
            (dir_part, base_name)
        """
        drv,path = cls.splitdrive(path)
        i = len(path)
        while i and path[i - 1] not in '/\\':
            i -= 1
        head, tail = path[:i], path[i:]

        # remove trailing slashes from head, unless it's all slashes
        head = head.rstrip('/\\') or head
        return (drv + head, tail)

    @staticmethod
    def splitdrive(path):
        """ Split a file path into a a drive part and remainder, for either cell or host,
        where the drive letter is separated with a colon.

        Parameters
        ----------
        path : str
            A path string as formatted for the host or for the cell. A trailing path separator is
            first stripped so that the last name field (basename) is not empty.

        Returns
        -------
        tuple:
            (drive_part, remainder)
        """
        if path[1:2] == ':':
            return (path[:2], path[2:])
        return ('', path)

    @classmethod
    def splitext(cls, path):
        """Split a file path into a everything except a trailing dotted-extension and the
        extension for either cell or host.

        Similar to os.path.splitext. Note that as with the Python os.path library, if the path
        consists of a leading dot, then that is considered a file name without an extent.

        Parameters
        ----------
        path : str
            A path string as formatted for the host or for the cell.

        Returns
        -------
        tuple:
            (all_but_ext, dotted_ext)
        """
        sep_pos = max(path.rfind(cls.sep), path.rfind(cls._alt_sep))
        dot_pos = path.rfind('.')
        if dot_pos > sep_pos:
            # If only leading dots, return the input path without extent; otherwise, return
            # the point at which the first dot on the right was found.
            name_pos = sep_pos + 1
            while name_pos < dot_pos:
                if path[name_pos] != '.':
                    return (path[:dot_pos], path[dot_pos:])
                name_pos += 1
        return (path, '')


class Cell(BasePath):
    """All Cell-specific path methods"""

    # Fixed Cell paths, in the format defined for the OS on the cell and mode of operation (MDW
    # real, MDW local, Windows development)
    sep = os.sep
    _alt_sep = '/' if sep == '\\' else '\\'

    _flash_root = pynative.flashpath()  # Cell persistent data volume (retained on reboot)
    _ram_root = pynative.rampath()  # Cell temp data volume (cleared on reboot)

    # Note that paths returned from pynative end in a path separator character. These are
    # stripped for compatibility with functions in os.path (and common practice), unless the
    # stripping leaves only a drive letter and colon.
    _flash_root = _flash_root.rstrip('/\\')
    _ram_root = _ram_root.rstrip('/\\')
    if _flash_root.endswith(':'): _flash_root += sep
    if _ram_root.endswith(':'): _ram_root += sep

    _temp_root = joiner(_ram_root, 'temp', sep)
    _config_root = joiner(_ram_root, 'config', sep)
    _data_root = joiner(_ram_root, 'data', sep)
    _program_root = joiner(_ram_root, 'bypass38', sep)
    _store_root = joiner(_flash_root, 'store', sep)

    # The current working directory is simulated for the Windows operating environment since the
    # real CWD is in the Windows file system, whereas it needs to be in the Cell file system,
    # starting with the flash drive. In the actual MDW environment, the OS manages the CWD.
    _cwd = _flash_root
    if on_windows:
        os.chdir(_cwd)

    # Temporary folders on Cell Ramdisk file system. These are cleared and recreated on Cell reboot,
    # but may also be cleared at any time during operation, especially between unit test module
    # runs.
    _temp_root_folders = [_temp_root, _config_root, _data_root]

    # Assure the temporary folders on the cell exist
    for _path in _temp_root_folders:
        os.makedirs(_path, exist_ok=True)

    @classmethod
    def configPath(cls, *subpath):
        """Return full path to Config folder on Cell, with optional subpath extension"""
        return cls.join(cls._config_root, *subpath)

    @classmethod
    def dataPath(cls, *subpath):
        """Return full path to Data folder on Cell, with optional subpath extension"""
        return cls.join(cls._data_root, *subpath)

    @classmethod
    def persistPath(cls, *subpath):
        """Return base path to the FlashDisk volume on Cell, with optional subpath extension"""
        return cls.join(cls._flash_root, *subpath)

    @classmethod
    def programPath(cls, *subpath):
        """Return full path to Python program folder on Cell, with optional subpath extension"""
        return cls.join(cls._program_root, *subpath)

    @classmethod
    def ramPath(cls, *subpath):
        """Return base path to the RamDisk volume on Cell, with optional subpath extension"""
        return cls.join(cls._ram_root, *subpath)

    @classmethod
    def storePath(cls, *subpath):
        """Return full path to Store folder on Cell, with optional subpath extension"""
        return cls.join(cls._store_root, *subpath)

    @classmethod
    def tempPath(cls, *subpath):
        """Return full path to Temp folder on Cell, with optional subpath extension"""
        return cls.join(cls._temp_root, *subpath)

    @classmethod
    def abspath(cls, path):
        """Get absolute path"""
        if not on_windows:
            return os.path.abspath(path)
        if not cls.isabs(path):
            cwd = os.getcwd()
            path = cls.join(cwd, path)
        return cls.normpath(path)

    @classmethod
    def chdir(cls, new_cwd):
        """Change to an existing directory on the cell

        The current working directory is simulated for the Windows operating environment since the
        real CWD is in the Windows file system. In the actual MDW environment, the OS manages the
        CWD.
        """
        if not on_windows:
            try:
                return os.chdir(new_cwd)
            except Exception as err:
                raise PathError(f"Unable to change CWD to {new_cwd}; {err}") from None
        new_cwd = cls.abspath(new_cwd)
        if cls.isdir(new_cwd):
            cls._cwd = new_cwd
            os.chdir(new_cwd)
        else:
            raise PathError(f"Unable to change CWD to {new_cwd}; path not found")

    @classmethod
    def createFolder(cls, cell_path):
        """Create a directory path on the cell, creating each missing folder in the tail

        Parameters
        ----------
        cell_path : str
            Directory path on cell

        Raises
        ------
        PathError:
            Unable to create a folder in the cell path
        """
        if verbosity > 1: print(f"path.cell.createFolder: cell_path={cell_path}")
        paths = []
        subpath = cell_path
        if subpath[-1] == cls.sep: subpath = subpath[:-1]
        while True:
            pos = subpath.rfind('\\')
            if pos == -1: break
            paths.append(subpath)
            subpath = subpath[:pos]

        to_make = []
        for path in paths:
            if os.path.isdir(path):
                break
            to_make.append(path)
        to_make.reverse()
        for path in to_make:
            os.mkdir(path)

    @classmethod
    def createTemporaryFolders(cls):
        """Create the temporary folders in RamDisk"""
        for _path in cls._temp_root_folders:
            os.makedirs(_path, exist_ok=True)

    @classmethod
    def getcwd(cls):
        """Get current working directory on the cell"""
        if not on_windows:
            return os.getcwd()
        return cls._cwd

    @staticmethod
    def info(file_path):
        """Get file information (size, modification time)

        Parameters
        ----------
        file_path : str
            Absolute path to a file on the cell

        Returns
        -------
        info : tuple of (int,float) or None
            If file exists, a tuple of (size, modification time) is returned. The modification time
            is the float value of the time provided by the Cell file system. If the file does not
            exist or is not a file, None is returned.
        """
        if os.path.isfile(file_path):
            stat = os.stat(file_path)
            return (stat.st_size, float(stat.st_mtime))
        return None

    @staticmethod
    def removeFile(file_path):
        """Remove file in cell

        The file_path must specify a path to an existing file in the cell file system. If the file
        does not exist, the function does nothing more without error. If the file exists.

        Parameters
        ----------
        file_path : str
            Absolute path to a file on the cell
        """
        if verbosity > 1: print(f"path.cell.removeFile: file_path={file_path}")
        try:
            os.remove(file_path)
        except FileNotFoundError:
            return
        except OSError as exc:
            raise PathError(f"OS Error in removing file {file_path}: {exc}") from None

    @staticmethod
    def removeFolder(folder_path):
        """Remove existing folder in cell

        The folder_path must specify a path to an existing folder in the cell file system. If that
        path does not exist, the function does nothing more without error. If that path exists, it
        is deleted, including any files or directory subpath within it.

        Parameters
        ----------
        folder_path : str  Absolute path to a folder on the cell
        """
        if verbosity > 1: print(f"path.cell.removeFolder: folder_path={folder_path}")
        shutil.rmtree(folder_path, ignore_errors=True)

    # ----
    # The following methods are functionally similar to os.path methods by the same name.
    # However, they differ from the os.path methods in that the path parameter may have either
    # host or cell separator, and all exceptions are converted to PathError.
    @staticmethod
    def exists(file_path):
        """Test whether a path exists.

        Parameters
        ----------
        file_path : str
            Absolute path to a file on the cell

        Returns
        -------
        exist : bool
            True if file exists.
        """
        return os.path.exists(file_path)

    @staticmethod
    def getmtime(file_path):
        """Return the last modification time of a file.

        Parameters
        ----------
        file_path : str  Absolute path to a file on the cell

        Returns
        -------
        mod_time : float
            Last modification time of file, as provided by the file system.
        """
        try:
            return os.path.getmtime(file_path)
        except FileNotFoundError:
            raise PathNotFoundError(file_path) from None
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def getsize(file_path):
        """Return the size of a file.

        Parameters
        ----------
        file_path : str  Absolute path to a file on the cell

        Returns
        -------
        size : int
            Number of bytes in file, without regard to encoding.
        """
        try:
            return os.path.getsize(file_path)
        except FileNotFoundError:
            raise PathNotFoundError(file_path)
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def isfile(file_path):
        """Return True if the path is an existing file.

        Parameters
        ----------
        file_path : str
            Absolute path to a file on the cell

        Returns
        -------
        exist : bool
            ``True`` if path exists as a file.
        """
        return os.path.isfile(file_path)

    @staticmethod
    def isdir(dir_path):
        """Return True if the pathname refers to an existing directory.

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell

        Returns
        -------
        exist : bool
            True if directory exists.
        """
        return os.path.isdir(dir_path)

    @classmethod
    def listdir(cls, dir_path):
        """Return list of paths found in directory ``dir_path``.

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell

        Returns
        -------
        files : list
            List of file names found in ``dir_path``.
        """
        return os.listdir(dir_path)

    # The following methods are functionally similar to os methods by the same name. However,
    # they differ from the os methods in that all exceptions are converted to PathError or
    # PathNotFoundError.
    @staticmethod
    def makedirs(dir_path, mode=0o777, exist_ok=False):
        """Make all folders in a path

        Super-mkdir; create a leaf directory and all intermediate ones.  Works like  mkdir, except
        that any intermediate path segment (not just the rightmost) will be created if it does not
        exist. If the target directory already exists, raise an PathError if exist_ok is False.
        Otherwise no exception is raised.  This is recursive.

        Parameters
        ----------
        dir_path : str
            Absolute path
        mode : int
            Mode flags in file system, meaningless to Serpente, but included for consistency with
            Python "os" library.
        exist_ok : bool
            If True, ignore error.
        """
        try:
            return os.makedirs(dir_path, mode, exist_ok)
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def remove(file_path):
        """Remove a file

        Parameters
        ----------

        file_path : str
            Path to existing file

        Raises
        ------
        PathNotFoundError : if file does not exist
        """
        try:
            return os.remove(file_path)
        except FileNotFoundError:
            raise PathNotFoundError(file_path)
        except Exception as err:
            raise PathError(err) from None

    @classmethod
    def removedirs(cls, dir_path):
        """Remove all directories under and including a specific path

        Unlike os.removedirs, the Serpente removedirs removes all everything, including files
        and folders, under the specified path. Actually using the os.removedirs in the Pharlap
        MDW may fail due to an invalid permission or "in use" error.

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell
        """
        cls.removeFolder(dir_path)

    @staticmethod
    def rmdir(dir_path):
        """Remove the directory if the directory is not empty

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell
        """
        try:
            return os.rmdir(dir_path)
        except Exception as err:
            raise PathError(err) from None

    @classmethod
    def rmtree(cls, dir_path):
        """Recursively delete a directory tree, ignoring any error

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell
        """
        try:
            cls.removeFolder(dir_path)
        except FileNotFoundError:
            raise PathNotFoundError(dir_path)
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def stat(file_path):
        """Generate a "os.stat_result" object describing the existing file

        Parameters
        ----------
        file_path : str
            Path to existing file

        Returns
        -------
        result : os.stat_result
            An stat_result object which provides file statistics. In particular, st_mtime and
            st_size should be the only members of interest, since the host variant provides only
            those two.
        """
        try:
            return os.stat(file_path)
        except FileNotFoundError:
            raise PathNotFoundError(file_path)
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def unlink(file_path):
        """Remove a file

        Parameters
        ----------
        file_path : str
            Path to existing file

        Raises
        ------
        PathNotFoundError : if file does not exist
        """
        try:
            return os.unlink(file_path)
        except FileNotFoundError:
            raise PathNotFoundError(file_path)
        except Exception as err:
            raise PathError(err) from None

    @staticmethod
    def walk(top, topdown=True):
        """Performs the os.walk method to traverse a directory subtree.

        Generate the file names in a directory tree by walking the tree either top-down or bottom-
        up. For each directory in the tree rooted at directory top (including top itself), it yields
        a 3-tuple (dirpath, dirnames, filenames).

        dirpath is a string, the path to the directory. dirnames is a list of the names of the
        subdirectories in dirpath (excluding '.' and '..'). filenames is a list of the names of the
        non-directory files in dirpath. Note that the names in the lists contain no path components.
        To get a full path (which begins with top) to a file or directory in dirpath, do
        os.path.join(dirpath, name).

        If optional argument topdown is True or not specified, the triple for a directory is
        generated before the triples for any of its subdirectories (directories are generated top-
        down). If topdown is False, the triple for a directory is generated after the triples for
        all of its subdirectories (directories are generated bottom-up). No matter the value of
        topdown, the list of subdirectories is retrieved before the tuples for the directory and its
        subdirectories are generated.

        When topdown is True, the caller can modify the dirnames list in-place (perhaps using del or
        slice assignment), and walk() will only recurse into the subdirectories whose names remain
        in dirnames; this can be used to prune the search, impose a specific order of visiting, or
        even to inform walk() about directories the caller creates or renames before it resumes
        walk() again. Modifying dirnames when topdown is False has no effect on the behavior of the
        walk, because in bottom-up mode the directories in dirnames are generated before dirpath
        itself is generated.

        For Serpente, the onerror and followlinks options of os.walk are not implemented and thus
        not presented in this method; usage of either option should raise a syntax error.

        Parameters
        ----------
        top : str
            Starting directory path to begin the walk
        topdown : bool, optional
            If True, walk the subtree top to bottom.

        Returns
        -------
        (dirpath, dirnames, filenames) : tuple
            dirpath is a string, the path to the directory. dirnames is a list of the names of the
            subdirectories in dirpath (excluding '.' and '..'). filenames is a list of the names
            of the non-directory files in dirpath. Note that the names in the lists contain no path
            components. To get a full path (which begins with top) to a file or directory in
            dirpath, do cell.path.join(dirpath, name)
        """
        return os.walk(top, topdown)


cell = Cell


class Host(BasePath):
    """All Host-specific path methods

    Until the MDW architecture changes, the host is exclusively a Windows PC which uses the
    backslash as the path separator.
    """

    # Host path separator for Windows
    sep = '\\'
    _alt_sep = '/'

    # Fixed host paths.
    _host_root = pynative.hostpath()

    # Note that paths returned from pynative end in a path separator character. This is
    # stripped for compatibility with functions in os.path (and common practice).
    _host_root = _host_root.rstrip('/\\')

    _asm_root = joiner(_host_root, 'assembler', sep)
    _config_root = joiner(_host_root, 'config', sep)
    _data_root = joiner(_host_root, 'DataCollection', sep)
    _ffprofile_root = joiner(_host_root, 'ffprofile', sep)
    _ini_root = joiner(_host_root, 'xyini', sep)
    _log_root = _data_root
    _python_root = joiner(_host_root, 'python', sep)
    _store_root = joiner(_data_root, 'store', sep)
    _temp_root = joiner(_host_root, 'temp', sep)
    _unittests_root = joiner(_host_root, 'python\\eng\\unittests', sep)
    _testfiles_root = joiner(_unittests_root, 'testfiles', sep)

    _repository_root = None

    # At this time, Aperio INI files are in the MDW root path (C:\Xyratex\Stw)
    _aperio_ini_root = _host_root

    # The current working directory is simulated for the host, with the starting CWD set to the
    # MDW root path. Host.getcwd and Host.chdir are used to get and change that simulated value.
    _cwd = _host_root

    # Create the host Temp folder if needed
    if not pynative.hostfolderexists_q(_temp_root):
        pynative.hostfoldercreate(_temp_root)

    @classmethod
    def aperioIniPath(cls, *subpath):
        """Return path to the Aperio INI files on Host, with optional subpath extension"""
        return cls.join(cls._aperio_ini_root, *subpath)

    @classmethod
    def asmPath(cls, *subpath):
        """Return path to the Assembler folder on Host, with optional subpath extension"""
        return cls.join(cls._asm_root, *subpath)

    @classmethod
    def configPath(cls, *subpath):
        """Return path to the Config folder on Host, with optional subpath extension"""
        return cls.join(cls._config_root, *subpath)

    @classmethod
    def dataPath(cls, *subpath):
        """Return path to the Data folder on Host, with optional subpath extension"""
        return cls.join(cls._data_root, *subpath)

    @classmethod
    def ffprofilePath(cls, *subpath):
        """Return path to the ffprofile folder on Host, with optional subpath extension"""
        return cls.join(cls._ffprofile_root, *subpath)

    @classmethod
    def iniPath(cls, *subpath):
        """Return path to the xyIni folder on Host, with optional subpath extension"""
        return cls.join(cls._ini_root, *subpath)

    @classmethod
    def logPath(cls, *subpath):
        """Return path to the DataCollection folder on Host, with optional subpath extension"""
        return cls.join(cls._log_root, *subpath)

    @classmethod
    def pythonPath(cls, *subpath):
        """Return path to the python folder on Host, with optional subpath extension"""
        return cls.join(cls._python_root, *subpath)

    @classmethod
    def rootPath(cls, *subpath):
        """Return path to the MDW root on Host, with optional subpath extension"""
        return cls.join(cls._host_root, *subpath)

    @classmethod
    def storePath(cls, *subpath):
        """Return path to the Store folder on Host, with optional subpath extension"""
        return cls.join(cls._store_root, *subpath)

    @classmethod
    def tempPath(cls, *subpath):
        """Return path to the Temp folder on Host, with optional subpath extension"""
        return cls.join(cls._temp_root, *subpath)

    @classmethod
    def testfilesPath(cls, *subpath):
        """Return path to the testfiles folder on Host, with optional subpath extension"""
        return cls.join(cls._testfiles_root, *subpath)

    @classmethod
    def unittestsPath(cls, *subpath):
        """Return path to the UnitTests folder on Host, with optional subpath extension"""
        return cls.join(cls._unittests_root, *subpath)

    @classmethod
    def abspath(cls, path):
        """Get absolute path on host"""
        if not cls.isabs(path):
            cwd = cls.getcwd()
            path = cls.join(cwd, path)
        return cls.normpath(path)

    @classmethod
    def chdir(cls, new_cwd):
        """Change to an existing directory on the host"""
        new_cwd = cls.abspath(new_cwd)
        if not cls.isdir(new_cwd):
            raise PathError(f"Unable to change CWD to {new_cwd}; path does not exist")
        cls._cwd = cls.abspath(new_cwd)

    @classmethod
    def copyFile(cls, source_path, destination):
        """Copy a file from one host folder to another.

        Not a true host-to-host copy, but a convenience utility function which downloads the host
        file to a temporary cell file, then uploads to the destination path.

        Parameters
        ----------
        source_path : str
            Full path to an existing file on the host.
        destination : str
            Full path to either an existing folder on the host, or new name of for the file
            copy within an existing folder on the host.

        Raises
        ------
        PathError:
            Unable to locate the source file, unable to locate destination folder,
            or unable to copy file.
        """
        if verbosity > 1: print(f"path.host.copyFile src={source_path}, dst={destination}")
        if not cls.isfile(source_path):
            raise PathError(f"Source file {source_path} not found on host")
        if cls.isdir(destination):
            destination_file = cls.join(destination, cls.split(source_path)[1])
        else:
            destination_file = destination
            destination_folder = cls.split(destination)[0]
            if not cls.isdir(destination_folder):
                raise PathError(f"Destination {destination} is not an existing folder")

        with cls.downloadFile(source_path) as cell_file:
            cls.uploadFile(destination_file, cell_file)

    @classmethod
    def createFolder(cls, host_path):
        """Create a directory path on the Host, creating each missing folder in the tail.

        Because the request sent to the host to create a folder is asynchronous with the check for
        folder existence, the create might not seem to work every time, so the create/check is
        attempted several times with a slight delay.

        If the function returns without exception, the host path either already exists,
        or was successfully created.

        Parameters
        ----------
        host_path : str
            Directory path on host.

        Raises
        ------
        PathError:
            Unable to create a folder in the host path.
        """
        if verbosity > 1: print(f"path.host.createFolder host_path={host_path}")
        paths = []
        subpath = host_path
        while True:
            pos = subpath.rfind('\\')
            if pos == -1: break
            paths.append(subpath)
            subpath = subpath[:pos]

        to_make = []
        for path in paths:
            if pynative.hostfolderexists_q(path):
                break
            to_make.append(path)
        to_make.reverse()
        for path in to_make:
            for _ in range(8):
                try:
                    pynative.hostfoldercreate(path)
                    if pynative.hostfolderexists_q(path):
                        break
                except RcError as exc:
                    raise PathError(exc, f"Unable to create host folder '{host_path}'") from None
                time.sleep(0.5)
            else:
                raise PathError(f"Unable to create host folder '{host_path}' "
                                f"after many attempts", rc=mdwec.XYB_RC_TIMEOUT)

    @classmethod
    @contextmanager
    def downloadFile(cls, host_file_path, cell_path=None, *, keep=None):
        """Load a host file to the cell temp folder, returning the path to a local copy.

        If the cell_path is not specified, a local file path in the Cell temp Path using the base
        name of the host_file_path. If the cell_path specifies an existing directory, the cell_path
        is formed from that directory and the host base name.

        If the local file is present on the cell, its contents is used and the host file is not
        downloaded again. Otherwise, the file on the host with the host_file_path is downloaded
        into the local file. In either case, the local file path is yielded for subsequent reading.

        At the end of the call of this method, if the "keep" parameter is False, the local file is
        removed, regardless of whether it previously existed or whether this method is called in a
        "with" context.

        Parameters
        ----------
        host_file_path : str
            A reference to an existing file on the host.
        cell_path : str
            If specified, this path is used to receive the downloaded contents. The cell_path may be
            an existing file or a directory path. If a directory path, the file name from the host
            path is combined with it for the local file.
        keep : bool
            If None (default), the function will choose to keep the local file or not. If
            explicitly True or False, the caller chooses the action.

        Yields
        ------
        path : str
            The full path to a local copy of the file.

        Examples
        --------
        Example of downloading a host file and loading as JSON text stream::

            import system.path as path
            host_path = path.host.configPath('head_case.json')
            with path.host.downloadFile(host_path) as jfile:
                json.load(jfile)

        """
        if verbosity > 1: print(f"path.host.downloadFile host_file_path={host_file_path}")
        (host_file_path, cell_file, exists, keep) = cls._resolveParameters(host_file_path,
                                                                           cell_path, keep)
        try:
            if not exists:
                try:
                    pynative.getfile(cell_file, host_file_path)
                except RcError as exc:
                    raise PathError(exc, f"Unable to get host file '{host_file_path}'") from None
                except FileNotFoundError:  # This occurs in Windows development
                    raise PathError(f"Host file '{host_file_path}' not found") from None
                except Exception:
                    raise PathError(f"Host file '{host_file_path}' not found") from None
            yield cell_file
        finally:
            if not keep and os.path.exists(cell_file):
                os.remove(cell_file)

    @classmethod
    def getcwd(cls):
        """Get current working directory on the host which is fixed as the MDW root path"""
        return cls._cwd

    @classmethod
    def getFile(cls, host_file_path, cell_path=None):
        """Load a host file to the cell temp folder, returning the path to a local copy.

        If the cell_path is not specified, a local file path in the Cell temp Path using the base
        name of the host_file_path. If the cell_path specifies an existing directory, the cell_path
        is formed from that directory and the host base name.

        If the local file is present on the cell, its contents is used and the host file is not
        downloaded again. Otherwise, the file on the host with the host_file_path is downloaded
        into the local file. In either case, the local file path is returned for subsequent reading.

        Use the downloadFile to get the file from the host within a "with" context, whereby the
        local is deleted when the "with" leaves scope.

        Parameters
        ----------
        host_file_path : str
            A reference to an existing file on the host.
        cell_path : str
            If specified, this path is used to receive the downloaded contents. The cell_path may be
            an existing file or a directory path. If a directory path, the file name from the host
            path is combined with it for the local file.

        Returns
        -------
        str:
            The full path to a local copy of the file.
        """
        if verbosity > 1: print(f"path.host.getFile: host_file_path={host_file_path}")
        (host_file_path, cell_file, exists, _) = cls._resolveParameters(host_file_path,
                                                                           cell_path, False)
        if not exists:
            try:
                pynative.getfile(cell_file, host_file_path)
            except RcError as exc:
                raise PathError(f"Unable to get host '{host_file_path}'", exc) from None
            except FileNotFoundError:  # This occurs in Windows development
                raise PathError(f"Unable to get host '{host_file_path}'") from None
            except Exception:
                raise PathError(f"Host file '{host_file_path}' not found") from None
        return cell_file

    @staticmethod
    def info(host_file_path):
        """Get file information (size, modification time)
        Parameters
        ----------
        host_file_path : str  Absolute path to a file on the host

        Returns
        -------
        info : tuple of (int,float) or None
            If file exists on the host, a tuple of (size, modification time) is returned. The
            modification time is the float value of the time provided by the host file system. If
            the file does not exist or is not a file, None is returned.
        """
        exists,mtime,size = pynative.hostfileexists_q(host_file_path)
        if exists:
            return (size, float(mtime))
        return None

    @classmethod
    def loadFile(cls, host_file_path, cell_path=None, *, func=None, binary=False, keep=None):
        """Load a host file to the cell temp folder, returning the contents as a single string.

        If the cell_path is not specified, a local file path in the Cell temp Path using the base
        name of the host_file_path. If the cell_path specifies an existing directory, the cell_path
        is formed from that directory and the host base name.

        If the local file is present on the cell, its contents is used and the host file is not
        downloaded again. Otherwise, the file on the host with the host_file_path is downloaded into
        the local file.

        If the function is specified, it is called with an opened file handle, allowing the function
        to iterate through the contents of the local file; the return value is as from the function
        call. If the function is not specified, the contents of the local file is read and returned
        as an unformatted string of data.

        The local file is opened as read-binary if the "binary" parameter is specified as True which
        may require decoding of the binary read from the file; otherwise, it is opened as text.

        Then, if the "keep" parameter is False, the local file is removed, regardless of whether it
        previously existed.

        Finally, the block of data is returned as a string to which the caller can apply encoding,
        splitting, etc.

        Parameters
        ----------
        host_file_path : str
            A reference to an existing file on the host
        cell_path : str
            If specified, this path is used to receive the downloaded contents. The cell_path may be
            an existing file or a directory path. If a directory path, the file name from the host
            path is combined with it for the local file.
        func : function
            Function to call with opened file handle to iterate through cell file.
        binary : bool
            Handle local file as binary data.
        keep : bool
            If False, the local file is unconditionally removed (default: keep local file). If
            None, the local file is deleted.

        Returns
        -------
        str:
            The contents of the host file if function not specified; otherwise the return value of
            the called function.
        """
        if verbosity > 1: print(f"path.host.loadFile: host_file_path={host_file_path}")
        return_value = None
        with cls.downloadFile(host_file_path, cell_path=cell_path, keep=keep) as cell_file:
            open_mode = 'r' if not binary else 'rb'
            with open(cell_file, open_mode) as fd:
                if func:
                    return_value = func(fd)
                else:
                    return_value = fd.read()
        return return_value

    @classmethod
    def loadFileList(cls, host_file_path, cell_path=None, *, keep=None):
        """Load a host file and return as a list of strings, as separated by newlines

        If the cell_path is not specified, a local file path in the Cell temp Path using the base
        name of the host_file_path. If the cell_path specifies an existing directory, the cell_path
        is formed from that directory and the host base name.

        If the local file is present on the cell, its contents is used and the host file is not
        downloaded again. Otherwise, the file on the host with the host_file_path is downloaded into
        the local file and the contents of the local file is read as newline-separated list of
        lines, stripped of trailing white space.

        Then, if the "keep" parameter is False, the local file is removed, regardless of whether it
        previously existed.

        Finally, the list of lines is returned.

        Parameters
        ----------
        host_file_path : str
            A reference to an existing file on the host
        cell_path : str
            If specified, this path is used to receive the downloaded contents. The cell_path may be
            an existing file or a directory path. If a directory path, the file name from the host
            path is combined with it for the local file.
        keep : bool
            If False, the local file is unconditionally removed (default: keep local file). If
            None, the local file is deleted.

        Returns
        -------
        list:
            List of lines in downloaded file.
        """
        if verbosity > 1: print(f"path.host.loadFileList: host_file_path={host_file_path}")
        lines = []
        lines = cls.loadFile(host_file_path, cell_path=cell_path, keep=keep, binary=False,
                     func=lambda handle: [line.rstrip() for line in handle])
        return lines

    @classmethod
    def loadFileObject(cls, host_file_path, cell_path=None, *, keep=None):
        """Load a host file and evaluate as a Python object.

        If the cell_path is not specified, a local file path in the Cell temp Path using the base
        name of the host_file_path. If the cell_path specifies an existing directory, the cell_path
        is formed from that directory and the host base name.

        If the local file is present on the cell, its contents is used and the host file is not
        downloaded again. Otherwise, the file on the host with the host_file_path is downloaded into
        the local file and the textual contents of the local file is read and evaluated as a Python
        object.

        Then, if the "keep" parameter is False, the local file is removed, regardless of whether it
        previously existed.

        Finally, the Python object is returned. Because the "eval" built-in function is used, this
        object may be a dict, list, set, string or numeric. If the eval fails, an appropriate
        exception, such as SyntaxError, is raised.

        Parameters
        ----------
        host_file_path : str
            A reference to an existing file on the host
        cell_path : str
            If specified, this path is used to receive the downloaded contents. The cell_path may be
            an existing file or a directory path. If a directory path, the file name from the host
            path is combined with it for the local file.
        keep : bool
            If False, the local file is unconditionally removed (default: keep local file). If
            None, the local file is deleted.

        Returns
        -------
        object:
            Python object evaluated from downloaded file.
        """
        if verbosity > 1: print(f"path.host.loadFileObject: host_file_path={host_file_path}")
        obj_str = cls.loadFile(host_file_path, cell_path=cell_path, keep=keep)
        return eval(obj_str)

    @staticmethod
    def removeFile(host_file_path):
        """Remove existing file in host.

        The host_file_path must specify a path to a file in the Windows file system of the host. If
        that file does not exist, the function does nothing more without error.

        Parameters
        ----------
        host_file_path : str
            Absolute path to a file on the host.
        """
        if verbosity > 1: print(f"path.host.removeFile: host_file_path={host_file_path}")
        try:
            pynative.hostfiledelete(host_file_path)
        except RcError as exc:
            if exc.rc != mdwec.XYB_RC_FILE_NOT_FOUND:
                raise PathError(f"Unable to remove host file {host_file_path}", exc) from None
        except FileNotFoundError:
            pass
        except OSError as exc:  # Windows-based testing
            raise PathError(f"Unable to remove host file {host_file_path}", exc) from None

    @staticmethod
    def removeFolder(host_folder_path):
        """Remove existing folder in host.

        The host_folder_path must specify a path to a folder in the Windows file system of the host.
        If that path does not exist, the function does nothing more without error. If that path
        exists, it is deleted, including any files or directory subpath within it. There is no
        validation of the host path, so if an incorrect path is used, there could be inadvertent
        permanent damage to the Windows file system.

        Parameters
        ----------
        host_folder_path : str
            Absolute path to a folder on the host.
        """
        if verbosity > 1: print(f"path.host.removeFolder: host_folder_path={host_folder_path}")
        try:
            pynative.hostfolderdelete(host_folder_path)
        except RcError as exc:  # Windows-based testing
            if exc.rc != mdwec.XYB_RC_DIRECTORY_NOT_FOUND:
                raise PathError(f"Unable to remove host file {host_folder_path}", exc) from None
        except OSError as exc:  # Windows-based testing
            raise PathError(f"Unable to remove host folder {host_folder_path}", exc) from None

    @classmethod
    def uploadFile(cls, host_file_path, cell_path=None, *, contents=None, func=None,
                   binary=False, keep=None):
        """Send a local file to the host.

        The cell_path is uploaded to the host in the host path. If the cell_path is not specified,
        the file by the same name as the host base name in the Cell Temp path is used. If an
        existing directory is specified for the cell_path, the file by the same name as the host
        base name in that directory is used.

        Alternative options for creating the a cell file for upload are:

        * Specify "contents" parameter with a list of data to upload to the file unmodified
        * Specify a function to generate the cell_file from an opened file handle.

        If the binary option is True, str data is converted to bytearray and written to the
        binary file. If false, bytearray data is converted to string type and written as a test
        file (default).

        After the upload is complete, the local file is deleted, unless the "keep" option is
        explicitly True. If "contents" is used, the local is always deleted afterwards.

        Parameters
        ----------
        host_file_path : str
            Destination file name which as an existing directory part.
        cell_path : str
            Cell file path, directory path, or None.
        contents : list or str
            String, list of strings, or None.
        func : function
            Optional function to call for generating content in open local file.
        binary : bool
            Handle local file as binary data.
        keep : bool
            If explicitly True, the local file is retained after the operation (default is to
            delete).

        Returns
        -------
        object:
            If function is specified, the value from the function call is returned; otherwise,
            None.
        """
        if verbosity > 1: print(f"path.host.uploadFile: host_file_path={host_file_path}")
        # _write function converts data str->bytearray or bytearray->str, depending on binary option
        def _write(fd, data):
            if binary:
                if isinstance(data, str):
                    fd.write(bytearray(data, 'utf-8'))
                else:
                    fd.write(data)
            else:
                if isinstance(data, bytearray):
                    fd.write(data.decode('utf-8'))
                else:
                    fd.write(data)

        (host_file_path, cell_file, exists, keep) = (
                cls._resolveParameters(host_file_path, cell_path, keep, name='_upload_contents'))

        return_value = None
        open_mode = 'w' if not binary else 'wb'

        # If contents is specified it may be a string or bytearray, or a list of such
        if contents is not None:
            keep = False
            with open(cell_file, open_mode) as fd:
                exists = True
                if isinstance(contents, list):
                    for data  in contents:
                        _write(fd, data)
                else:
                    _write(fd, contents)
        # If function is specified, it is called with the opened local file handle
        elif func is not None:
            keep = False
            with open(cell_file, open_mode) as handle:
                exists = True
                return_value = func(handle)

        if not exists:
            raise PathError(f"Cell file '{cell_file}' does not exist",
                            rc=mdwec.XYB_RC_FILE_NOT_FOUND)

        try:
            pynative.sendfile(host_file_path, cell_file)
        except RcError as exc:
            if exc.rc == mdwec.XYB_RC_HOSTSENDFILE_FAILED:
                raise PathError(f"Unable to send '{cell_file}' to host '{host_file_path}",
                                exc) from None
            if exc.rc == mdwec.XYB_RC_FILE_NOT_FOUND:
                raise PathError(f"No local file '{cell_file}'", exc) from None
            raise PathError('Error in sendfile', exc) from None
        except (OSError, FileNotFoundError):  # Handle error for Windows testing
            raise PathError(f"Unable to send '{cell_file}' to host '{host_file_path}",
                              rc=mdwec.XYB_RC_FILE_NOT_FOUND) from None
        finally:
            if not keep and os.path.isfile(cell_file):
                os.remove(cell_file)
        return return_value

    @classmethod
    def _resolveParameters(cls, host_file, local_path, keep, name=None):
        """Harden the caller indefinite parameters into actual paths.

        This function returns a tuple of exact host and local file paths, a "keep" flag, and a "pre-
        existing" flag, depending upon the input parameters.

        A local file path is determined as follows:
        *   If the local_path is None, then the cell Temp folder path and the host base filename are
            joined for the local file path
        *   If the local_path identifies a directory, then that path and the host base filename are
            joined for the local file path
        *   If the local_path identifies a preexisting file, then that path is used unchanged.

        If the host_file string ends with '\\', is is assumed to be a directory. If the local file
        is fully resolved, its base filename is used for the host base filename.

        If the input "keep" is None, then the returned "keep" is True if the local file is
        preexisting, or False if the file must be downloaded from the host host.

        Parameters
        ----------
        host_file : str
            host path.
        local_path : str
            Local file, directory, or None.
        keep : bool
            True, false, or None.
        name : str
            File name for temp cell (default: use host file name).

        Returns
        -------
        tuple:
            (host_file_path, cell_file, exists, keep)
        """
        if local_path is None:
            local_path = cell.tempPath(name)
        elif os.path.isfile(local_path):
            if keep is None: keep = True
            if host_file[-1] == '\\':
                host_file = host_file + os.path.split(local_path)[1]
            if verbosity > 1: print(f"   resolve: host={host_file}, cell={local_path}, "
                              f"exists=True, keep={keep}")
            return (host_file, local_path, True, keep)

        if os.path.isdir(local_path):
            base_name = cls.basename(host_file)
            local_path = os.path.join(local_path, base_name)
        if os.path.isfile(local_path):
            if keep is None: keep = True
            if host_file[-1] == '\\':
                host_file = host_file + os.path.split(local_path)[1]
            if verbosity > 1: print(f"   resolve: host={host_file}, cell={local_path}, "
                              f"exists=True, keep={keep}")
            return (host_file, local_path, True, keep)
        if keep is None: keep = False
        if verbosity > 1: print(f"   resolve: host={host_file}, cell={local_path}, "
                          f"exists=False, keep={keep}")
        return (host_file, local_path, False, keep)

    @classmethod
    def installTestFiles(cls, dest_host_path, *args, **kwargs):   #pylint: disable=missing-param-doc
        """Copy files and/or folders from repository to a host path

        This function is useful only for unit tests running on either Windows development or in MDW
        local mode, although it does nothing in other operating environments.

        The host path is that obtained from a "path.host.xxxxxxPath" call to identify a destination
        folder. The remaining arguments identify either subpaths under the current repository or
        full paths in the Windows development system.

        Parameters
        ----------
        dest_host_path : str
            A host path to which file(s) are copied. It may be an existing directory, or a file
            name within an existing directory. If a file, there must be one and only one source
            file.
        args : Tuple[str]
            One or more subpaths under the repository root identifying source folders or files
            to copy into the host destination path.
        ignore_error : bool
            If True, any error arising from copy attempts are ignored. Copying is
            attempted on each source path. If the destination path is invalid or the current
            working directory is not in a repository, an exception is still raised. (Default
            is False.) Optional.

        Examples
        --------
        Examples of installing test files from <repo>/.../unittests/mocking/config folder to
        host config::

            host_config = path.host.configPath()
            path.host.installTestFiles(host_config, 'config', mock=True)

        Example of installing a single "event.json" file from repo default config folder to host
        config::

            path.host.installTestFiles(host_config, 'xyratex/stw/config/event.json')

        """
        if sys.platform != 'win32':
            return
        if verbosity > 1: print(f"path.host.installTestFiles: dest_host_path={dest_host_path}")

        if not args:
            raise PathError("path.host.installTestFiles called without source file")
        raise_on_error = not kwargs.pop('ignore_error', False)

        if verbosity > 1: print(f"path.host.installTestFiles: dest_host_path={dest_host_path}, "
                          f"source={args}")

        def _locateSource(src):
            """Locate the source path"""
            src = src.replace('/', os.sep)
            if src[1] != ':':
                src_path = cls._discoverRepositoryPath(src)
            else:
                src_path = src
            return src_path

        # Check for a special case of single source and single destination folder or file to rename
        if not os.path.isdir(dest_host_path):
            dest_path = cls.split(dest_host_path)[0]
            if not os.path.isdir(dest_path):
                raise PathError(f"{dest_host_path} is not a directory")
            if len(args) != 1:
                raise PathError("path.host.installTestFiles called with too many source files")
            try:
                src = ''
                src = _locateSource(args[0])
                shutil.copy(src, dest_host_path)
            except (FileNotFoundError, OSError) as exc:
                if raise_on_error:
                    raise PathError(f"Failure in shutil.copy for {src}", exc) from None
            return

    # For each source file or older, locate its full path. Use shutil.copytree to copy folders,
    # and shutil.copy to copy files.
        for src in args:
            src_path = _locateSource(src)
            if os.path.isdir(src_path):
                try:
                    shutil.copytree(src_path, dest_host_path, dirs_exist_ok=True)
                except FileNotFoundError:
                    if raise_on_error:
                        raise PathError(f"Source path {src_path} not found") from None
                except Exception as exc:
                    if raise_on_error:
                        raise PathError(f"Unable to copy source path {src_path} to "
                                        f"{dest_host_path}", exc) from None
            elif os.path.isfile(src_path):
                try:
                    shutil.copy(src_path, dest_host_path)
                except (FileNotFoundError, OSError):
                    if raise_on_error:
                        raise PathError(f"Failure in shutil.copy for {src}") from None
            elif raise_on_error:
                raise PathError(f"No source path {src_path}")

    @classmethod
    def _discoverRepositoryPath(cls, *subpaths):
        """Locate repository root from current working directory"""
        if cls._repository_root is None:
            repo = os.path.dirname(os.path.abspath(__file__))
            previous = None
            while True:
                try:
                    if os.path.isdir(os.path.join(repo, '.git')):
                        cls._repository_root = repo
                        break
                    previous = repo
                    repo = os.path.abspath(os.path.join(repo, '..'))
                    if repo == previous:
                        break
                except (FileNotFoundError, NotADirectoryError, OSError):
                    break
            if cls._repository_root is None:
                raise PathError("Unable to discover repository from current working directory")
        return os.path.join(cls._repository_root, *subpaths)

    # ----
    # The following methods are functionally similar to os.path methods by the same name,
    # but implemented as required within the limitations of the host interface. All exceptions
    # are converted to PathError.
    @staticmethod
    def exists(host_file_path):
        """Determine whether the file path exists as a file or directory on the host.

        Parameters
        ----------
        host_file_path : str
            host path.

        Returns
        -------
        exists : bool
            The input string does identify as an existing file or directory on the host.
        """
        if pynative.hostfileexists_q(host_file_path)[0]:
            return True
        return pynative.hostfolderexists_q(host_file_path)

    @staticmethod
    def getmtime(host_file_path):
        """Get the last modified time of a host file

        Parameters
        ----------
        host_file_path : str
            host path.

        Returns
        -------
        mtime : float
            The last modified timestamp of the host file

        Raises
        ------
        PathNotFoundError if the file does not exist on the host
        """
        exists, mtime, size = pynative.hostfileexists_q(host_file_path)
        if exists:
            return mtime
        raise PathNotFoundError(host_file_path)

    @staticmethod
    def getsize(host_file_path):
        """Get the size in bytes of a host file

        Parameters
        ----------
        host_file_path : str
            host path.

        Returns
        -------
        size : int
            The number of bytes reportedly in the host file

        Raises
        ------
        PathNotFoundError if the file does not exist on the host
        """
        exists, mtime, size = pynative.hostfileexists_q(host_file_path)
        if exists:
            return int(size)
        raise PathNotFoundError(host_file_path)

    @staticmethod
    def isfile(host_file_path):
        """Determine if the file path is that of an existing file on the host.

        The implementation of checking existence of a host file also returns ``True`` if the path is
        a directory. This function checks first for existence and then checks if it is a folder to
        assure that the path is that of a file.

        Parameters
        ----------
        host_file_path : str
            host path.

        Returns
        -------
        exists : bool
            True if the path is that of an existing file on the host.
        """
        if pynative.hostfileexists_q(host_file_path)[0]:
            if not pynative.hostfolderexists_q(host_file_path):
                return True
        return False

    @staticmethod
    def isdir(host_dir_path):
        """Determine if the file path is that of an existing folder on the host.

        Parameters
        ----------
        host_dir_path : str
            host path.

        Returns
        -------
        exists : bool
            True if the path is that of an existing folder on the host.
        """
        return pynative.hostfolderexists_q(host_dir_path)

    # The following methods are functionally similar to "os" methods by the same name, or for
    # "shutil" in th ecase of rmtree. However, they differ from the "os" methods in that the path
    # parameter may have either host or cell separator, and all exceptions are converted to
    # PathError.
    @classmethod
    def makedirs(cls, host_dir_path, exist_ok=False):
        """Create a full path on the host

        Similar to the os.makedirs, except that the exist_ok keyword is ignored. The expectation in
        Serpente is that if this function is called, the path needs to exist upon exit, creating the
        full directory hierarchy if it does not.

        Parameters
        ----------
        host_dir_path : str
            Directory path to create
        exist_ok : bool
            Ignored. If the path already exists, no action is taken and no exception results.
        """
        cls.createFolder(host_dir_path)

    @classmethod
    def remove(cls, host_file_path):
        """Remove host file

        Similar to os.remove, except that if the files does not exist, no exception is raised. In
        Serpente, the expectation is that ultimately, the file should not exist on the host.

        This method is also aliased by "unlink".

        Parameters
        ----------
        host_file_path : str
            Path of file on host.
        """
        cls.removeFile(host_file_path)
    unlink = remove

    @classmethod
    def removedirs(cls, dir_path):
        """Remove all directories under and including a specific path

        Parameters
        ----------
        dir_path : str  Absolute path to a folder on the cell
        """
        cls.removeFolder(dir_path)

    @classmethod
    def rmtree(cls, host_dir_path):
        """Remove directory subtree on host

        Similar to shutil.rmtree where the specified directory path on the host is removed,
        including all files and folders within it.

        Parameters
        ----------
        host_dir_path : str
            Path of folder on host.
        """
        cls.removeFolder(host_dir_path)

    @staticmethod
    def stat(host_file_path):
        """Returns an object containing st_mtime and st_size for an existing host file

        Parameters
        ----------
        host_file_path : str
            host path.

        Returns
        -------
        stat_result : object
            An object similar to os.stat_results but containing only two attributes:
                st_mtime : float
                st_size : int
        Raises
        ------
        PathNotFoundError if the file does not exist on the host.
        """
        exists, mtime, size = pynative.hostfileexists_q(host_file_path)
        if exists:
            class DummyStatResult:
                st_mtime = mtime
                st_size = size
            return DummyStatResult
        raise PathNotFoundError(host_file_path)

    @staticmethod
    def walk(top, topdown=True):
        """Performs the os.walk method to traverse a directory subtree, if implemented.

        This os.walk counterpart cannot be implemented for the host since the cell-to-host
        communication protocol has nothing to support the capability.
        """
        raise NotImplementedError("Host.walk method is not implemented")


host = Host
